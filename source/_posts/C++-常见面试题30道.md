---
title: c++常见面试题30道
date: 2019-7-23 19:48:09
toc: true
categories: 
 - [学习 - c/c++]
 - [生活 - 工作相关]
tags: 
 - 工作
---



**简介：**  c++常见面试题30道

<!-- more -->

[TOC]

## 本博文的简述or解决问题？

​		c++常见面试题30道

<br>

## <font color=#D0087E  face="幼圆">重要提示：</font>

<font color=#70AD47 size=4 face="幼圆">推荐点击文末的同步博客链接，查看本文，获得100%的浏览体验效果</font>

- 若遇csdn的博文的排版异常，图片无法加载，无法替换显示，则会删除异常部分（文末为无删减版）
- 无法预览的视频，则会替换为其链接；若学习资源分享失效，请评论区留言或留下邮箱
- <font color=#D0087E  size=4 face="幼圆">**请点击<font color=#FE7207  size=4 face="幼圆">本文末的同步链接</font>，在 [github.io](https://touwoyimuli.github.io/) 博客上查看更好的100%效果体验**</font> 

<br>



<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t0"></a>
<span style="font-size:32px;color:rgb(255,0,0);">1.new<span style="font-family:'宋体';">、</span><span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">、</span><span style="font-family:'ˎ̥';">malloc</span><span style="font-family:'宋体';">、</span><span style="font-family:'ˎ̥';">free</span><span style="font-family:'宋体';">关系</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">delete<span style="font-family:'宋体';">会调用对象的析构函数</span><span style="font-family:'ˎ̥';">,</span><span style="font-family:'宋体';">和</span><span style="font-family:'ˎ̥';">new</span><span style="font-family:'宋体';">对应</span><span style="font-family:'ˎ̥';">free</span><span style="font-family:'宋体';">只会释放内存，</span><span style="font-family:'ˎ̥';">new</span><span style="font-family:'宋体';">调用构造函数。</span><span style="font-family:'ˎ̥';">malloc</span><span style="font-family:'宋体';">与</span><span style="font-family:'ˎ̥';">free</span><span style="font-family:'宋体';">是</span><span style="font-family:'ˎ̥';">C++/C</span><span style="font-family:'宋体';">语言的标准库函数，</span><span style="font-family:'ˎ̥';">new/delete</span><span style="font-family:'宋体';">是</span><span style="font-family:'ˎ̥';">C++</span><span style="font-family:'宋体';">的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用</span><span style="font-family:'ˎ̥';">maloc/free</span><span style="font-family:'宋体';">无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于</span><span style="font-family:'ˎ̥';">malloc/free</span><span style="font-family:'宋体';">是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于</span><span style="font-family:'ˎ̥';">malloc/free</span><span style="font-family:'宋体';">。因此</span><span style="font-family:'ˎ̥';">C++</span><span style="font-family:'宋体';">语言需要一个能完成动态内存分配和初始化工作的运算符</span><span style="font-family:'ˎ̥';">new</span><span style="font-family:'宋体';">，以及一个能完成清理与释放内存工作的运算符</span><span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">。注意</span><span style="font-family:'ˎ̥';">new/delete</span><span style="font-family:'宋体';">不是库函数。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t1"></a>
<a name="t2" style="color:rgb(202,0,0);"></a><a name="t1" style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">2.delete<span style="font-family:'宋体';">与&nbsp;</span><span style="font-family:'ˎ̥';">delete&nbsp;[]</span><span style="font-family:'宋体';">区别</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">delete<span style="font-family:'宋体';">只会调用一次析构函数，而</span><span style="font-family:'ˎ̥';">delete[]</span><span style="font-family:'宋体';">会调用每一个成员的析构函数。在</span><span style="font-family:'ˎ̥';">More&nbsp;Effective&nbsp;C++</span><span style="font-family:'宋体';">中有更为详细的解释：</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">当</span><span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">操作符用于数组时，它为每个数组元素调用析构函数，然后调用</span><span style="font-family:'ˎ̥';">operator</span></span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">delete<span style="font-family:'宋体';">来释放内存。</span><span style="font-family:'ˎ̥';">”delete</span><span style="font-family:'宋体';">与</span></span><span style="font-size:18px;color:rgb(0,0,0);">n</span><span style="font-size:18px;color:rgb(0,0,0);">ew<span style="font-family:'宋体';">配套，</span><span style="font-family:'ˎ̥';">delete&nbsp;[]</span><span style="font-family:'宋体';">与</span><span style="font-family:'ˎ̥';">new&nbsp;[]</span><span style="font-family:'宋体';">配套</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">MemTest</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">*mTest1=new</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">MemTest[10];</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">MemTest</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">*mTest2=new</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">MemTest;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">Int</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">*pInt1=new</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">int</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">[10];</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">Int</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">*pInt2=new</span><span style="font-size:18px;color:rgb(0,0,0);">&nbsp;</span><span style="font-size:18px;color:rgb(0,0,0);">int;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">delete[]pInt1;&nbsp;//-1-</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">delete[]pInt2;&nbsp;//-2-</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">delete[]mTest1;//-3-</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">delete[]mTest2;//-4-</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">在<span style="font-family:'ˎ̥';">-4-</span><span style="font-family:'宋体';">处报错。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">这就说明：对于内建简单数据类型，<span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">和</span><span style="font-family:'ˎ̥';">delete[]</span><span style="font-family:'宋体';">功能是相同的。对于自定义的复杂数据类型，</span><span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">和</span><span style="font-family:'ˎ̥';">delete[]</span><span style="font-family:'宋体';">不能互用。</span><span style="font-family:'ˎ̥';">delete[]</span><span style="font-family:'宋体';">删除一个数组，</span><span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">删除一个指针。简单来说，用</span><span style="font-family:'ˎ̥';">new</span><span style="font-family:'宋体';">分配的内存用</span><span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">删除；用</span><span style="font-family:'ˎ̥';">new[]</span><span style="font-family:'宋体';">分配的内存用</span><span style="font-family:'ˎ̥';">delete[]</span><span style="font-family:'宋体';">删除</span><span style="font-family:'ˎ̥';">。delete[]</span><span style="font-family:'宋体';">会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用</span><span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">时没用括号，</span><span style="font-family:'ˎ̥';">delete</span><span style="font-family:'宋体';">就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t2"></a>
<a name="t3" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">3</span><span style="font-size:32px;color:rgb(255,0,0);">.C++<span style="font-family:'宋体';">有哪些性质（面向对象特点）</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">封装，继承和多态。</span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t3"></a>
<a name="t4" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">4</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">子类析构时要调用父类的析构函数吗？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候<span style="font-family:'ˎ̥';">,</span><span style="font-family:'宋体';">派生类的信息已经全部销毁了</span></span><span style="font-size:18px;color:rgb(0,0,0);">。</span><span style="font-size:18px;color:rgb(0,0,0);">定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数</span><span style="font-size:18px;color:rgb(0,0,0);">。</span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t4"></a>
<a name="t5" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">5</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">多态，虚函数，纯虚函数</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">多态：是对于不同对象接收相同消息时产生不同的动作。<span style="font-family:'ˎ̥';">C++</span><span style="font-family:'宋体';">的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">在程序编译时多态性体现在函数和运算符的重载上；</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">虚函数：在基类中冠以关键字&nbsp;<span style="font-family:'ˎ̥';">virtual&nbsp;</span><span style="font-family:'宋体';">的成员函数。&nbsp;它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在&nbsp;纯虚函数不具备函数的功能，一般不能直接被调用。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（<span style="font-family:'ˎ̥';">abstract&nbsp;class</span><span style="font-family:'宋体';">）。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。</span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t5"></a>
<a name="t6" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">6</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">求下面函数的返回值（微软）</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">int&nbsp;func(x)&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">{&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">int&nbsp;countx&nbsp;=&nbsp;0;&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">while(x)&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">{&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">countx&nbsp;++;&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">x&nbsp;=&nbsp;x&amp;(x-1);&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">}&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">return&nbsp;countx;&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">}&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">假定<span style="font-family:'ˎ̥';">x&nbsp;=&nbsp;9999</span><span style="font-family:'宋体';">。&nbsp;答案：</span><span style="font-family:'ˎ̥';">8</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">思路：将<span style="font-family:'ˎ̥';">x</span><span style="font-family:'宋体';">转化为</span><span style="font-family:'ˎ̥';">2</span><span style="font-family:'宋体';">进制，看含有的</span><span style="font-family:'ˎ̥';">1</span><span style="font-family:'宋体';">的个数。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t6"></a>
<a name="t7" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">7</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">什么是</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">引用</span><span style="font-family:'ˎ̥';">”</span><span style="font-family:'宋体';">？申明和使用</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">引用</span><span style="font-family:'ˎ̥';">”</span><span style="font-family:'宋体';">要注意哪些问题？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">答：引用就是某个目标变量的<span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">别名</span><span style="font-family:'ˎ̥';">”(alias)</span><span style="font-family:'宋体';">，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t7"></a>
<a name="t8" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">8</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">将</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">引用</span><span style="font-family:'ˎ̥';">”</span><span style="font-family:'宋体';">作为函数参数有哪些特点？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">（<span style="font-family:'ˎ̥';">1</span><span style="font-family:'宋体';">）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">（<span style="font-family:'ˎ̥';">2</span><span style="font-family:'宋体';">）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">（<span style="font-family:'ˎ̥';">3</span><span style="font-family:'宋体';">）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用</span><span style="font-family:'ˎ̥';">"*</span><span style="font-family:'宋体';">指针变量名</span><span style="font-family:'ˎ̥';">"</span><span style="font-family:'宋体';">的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t8"></a>
<a name="t9" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">9</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">在什么时候需要使用</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">常引用</span><span style="font-family:'ˎ̥';">”</span><span style="font-family:'宋体';">？　</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：<span style="font-family:'ˎ̥';">const&nbsp;</span><span style="font-family:'宋体';">类型标识符&nbsp;</span><span style="font-family:'ˎ̥';">&amp;</span><span style="font-family:'宋体';">引用名</span><span style="font-family:'ˎ̥';">=</span><span style="font-family:'宋体';">目标变量名；</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">例<span style="font-family:'Times New Roman';">1</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">int&nbsp;a&nbsp;;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">const&nbsp;int&nbsp;&amp;ra=a;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">ra=1;&nbsp;//<span style="font-family:'宋体';">错误</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">a=1;&nbsp;//<span style="font-family:'宋体';">正确</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">例<span style="font-family:'Times New Roman';">2</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">string&nbsp;foo(&nbsp;);</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">void&nbsp;bar(string&nbsp;&amp;&nbsp;s);</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">那么下面的表达式将是非法的：</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">bar(foo(&nbsp;));</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">bar("hello&nbsp;world");</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">原因在于<span style="font-family:Calibri;">foo(&nbsp;)</span><span style="font-family:'宋体';">和</span><span style="font-family:Calibri;">"hello&nbsp;world"</span><span style="font-family:'宋体';">串都会产生一个临时对象，而在</span><span style="font-family:Calibri;">C++</span><span style="font-family:'宋体';">中，这些临时对象都是</span><span style="font-family:Calibri;">const</span><span style="font-family:'宋体';">类型的。因此上面的表达式就是试图将一个</span><span style="font-family:Calibri;">const</span><span style="font-family:'宋体';">类型的对象转换为非</span><span style="font-family:Calibri;">const</span><span style="font-family:'宋体';">类型，这是非法的。引用型参数应该在能被定义为</span><span style="font-family:Calibri;">const</span><span style="font-family:'宋体';">的情况下，尽量定义为</span><span style="font-family:Calibri;">const&nbsp;</span><span style="font-family:'宋体';">。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t9"></a>
<a name="t10" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:18px;"><span style="font-family:'宋体';"></span></span>
</h1><p>
<span style="font-size:32px;color:rgb(255,0,0);">10.<span style="font-family:'宋体';">将</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">引用</span><span style="font-family:'ˎ̥';">”</span><span style="font-family:'宋体';">作为函数返回值类型的格式、好处和需要遵守的规则</span><span style="font-family:'ˎ̥';">?</span></span></p>

<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;"><span style="font-family:'宋体';"></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">格式：类型标识符&nbsp;<span style="font-family:'ˎ̥';">&amp;</span><span style="font-family:'宋体';">函数名（形参列表及类型说明）</span><span style="font-family:'ˎ̥';">{&nbsp;//</span><span style="font-family:'宋体';">函数体&nbsp;</span><span style="font-family:'ˎ̥';">}</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生<span style="font-family:'ˎ̥';">runtime&nbsp;error!&nbsp;<br></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);"><span style="font-family:'ˎ̥';"></span><span style="font-family:'宋体';">注意事项：</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">（<span style="font-family:'ˎ̥';">1</span><span style="font-family:'宋体';">）不能返回局部变量的引用。这条可以参照</span><span style="font-family:'ˎ̥';">Effective&nbsp;C++[1]</span><span style="font-family:'宋体';">的</span><span style="font-family:'ˎ̥';">Item&nbsp;31</span><span style="font-family:'宋体';">。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了</span><span style="font-family:'ˎ̥';">"</span><span style="font-family:'宋体';">无所指</span><span style="font-family:'ˎ̥';">"</span><span style="font-family:'宋体';">的引用，程序会进入未知状态。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">（<span style="font-family:'ˎ̥';">2</span><span style="font-family:'宋体';">）不能返回函数内部</span><span style="font-family:'ˎ̥';">new</span><span style="font-family:'宋体';">分配的内存的引用。这条可以参照</span><span style="font-family:'ˎ̥';">Effective&nbsp;C++[1]</span><span style="font-family:'宋体';">的</span><span style="font-family:'ˎ̥';">Item&nbsp;31</span><span style="font-family:'宋体';">。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部</span><span style="font-family:'ˎ̥';">new</span><span style="font-family:'宋体';">分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由</span><span style="font-family:'ˎ̥';">new</span><span style="font-family:'宋体';">分配）就无法释放，造成</span><span style="font-family:'ˎ̥';">memory&nbsp;leak</span><span style="font-family:'宋体';">。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">（<span style="font-family:'ˎ̥';">3</span><span style="font-family:'宋体';">）可以返回类成员的引用，但最好是</span><span style="font-family:'ˎ̥';">const</span><span style="font-family:'宋体';">。这条原则可以参照</span><span style="font-family:'ˎ̥';">Effective&nbsp;C++[1]</span><span style="font-family:'宋体';">的</span><span style="font-family:'ˎ̥';">Item&nbsp;30</span><span style="font-family:'宋体';">。主要原因是当对象的属性是与某种业务规则（</span><span style="font-family:'ˎ̥';">business&nbsp;rule</span><span style="font-family:'宋体';">）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">（<span style="font-family:'ˎ̥';">4</span><span style="font-family:'宋体';">）流操作符重载返回值申明为</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">引用</span><span style="font-family:'ˎ̥';">”</span><span style="font-family:'宋体';">的作用：</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">流操作符<span style="font-family:'ˎ̥';">&lt;&lt;</span><span style="font-family:'宋体';">和</span><span style="font-family:'ˎ̥';">&gt;&gt;</span><span style="font-family:'宋体';">，这两个操作符常常希望被连续使用，例如：</span><span style="font-family:'ˎ̥';">cout&nbsp;&lt;&lt;&nbsp;"hello"&nbsp;&lt;&lt;&nbsp;endl;</span><span style="font-family:'宋体';">　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个</span><span style="font-family:'ˎ̥';">&lt;&lt;</span><span style="font-family:'宋体';">操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用</span><span style="font-family:'ˎ̥';">&lt;&lt;</span><span style="font-family:'宋体';">操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是</span><span style="font-family:'ˎ̥';">C++</span><span style="font-family:'宋体';">语言中引入引用这个概念的原因吧。&nbsp;<br></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);"><span style="font-family:'宋体';">赋值操作符</span><span style="font-family:'ˎ̥';">=</span><span style="font-family:'宋体';">。这个操作符象流操作符一样，是可以连续使用的，例如：</span><span style="font-family:'ˎ̥';">x&nbsp;=&nbsp;j&nbsp;=&nbsp;10;</span><span style="font-family:'宋体';">或者</span><span style="font-family:'ˎ̥';">(x=10)=100;</span><span style="font-family:'宋体';">赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">＃<span style="font-family:'ˎ̥';">include&lt;iostream.h&gt;</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">int&nbsp;&amp;put(int&nbsp;n);</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">int&nbsp;vals[10];</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">int&nbsp;error=-1;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">void&nbsp;main()</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">{</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">put(0)=10;&nbsp;//<span style="font-family:'宋体';">以</span><span style="font-family:'ˎ̥';">put(0)</span><span style="font-family:'宋体';">函数值作为左值，等价于</span><span style="font-family:'ˎ̥';">vals[0]=10;&nbsp;</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">put(9)=20;&nbsp;//<span style="font-family:'宋体';">以</span><span style="font-family:'ˎ̥';">put(9)</span><span style="font-family:'宋体';">函数值作为左值，等价于</span><span style="font-family:'ˎ̥';">vals[9]=20;&nbsp;</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">cout&lt;&lt;vals[0];&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">cout&lt;&lt;vals[9];</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">}&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">int&nbsp;&amp;put(int&nbsp;n)</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">{</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">if&nbsp;(n&gt;=0&nbsp;&amp;&amp;&nbsp;n&lt;=9&nbsp;)&nbsp;return&nbsp;vals[n];&nbsp;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">else&nbsp;{&nbsp;cout&lt;&lt;"subscript&nbsp;error";&nbsp;return&nbsp;error;&nbsp;}</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">}</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);">（<span style="font-family:'ˎ̥';">5</span><span style="font-family:'宋体';">）在另外的一些操作符中，却千万不能返回引用：</span><span style="font-family:'ˎ̥';">+-*/&nbsp;</span><span style="font-family:'宋体';">四则运算符。它们不能返回引用，</span><span style="font-family:'ˎ̥';">Effective&nbsp;C++[1]</span><span style="font-family:'宋体';">的</span><span style="font-family:'ˎ̥';">Item23</span><span style="font-family:'宋体';">详细的讨论了这个问题。主要原因是这四个操作符没有</span><span style="font-family:'ˎ̥';">side&nbsp;effect</span><span style="font-family:'宋体';">，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个</span><span style="font-family:'ˎ̥';">new</span><span style="font-family:'宋体';">分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第</span><span style="font-family:'ˎ̥';">2</span><span style="font-family:'宋体';">、</span><span style="font-family:'ˎ̥';">3</span><span style="font-family:'宋体';">两个方案都被否决了。静态对象的引用又因为</span><span style="font-family:'ˎ̥';">((a+b)&nbsp;==&nbsp;(c+d))</span><span style="font-family:'宋体';">会永远为</span><span style="font-family:'ˎ̥';">true</span><span style="font-family:'宋体';">而导致错误。所以可选的只剩下返回一个对象了。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(0,0,0);"><span style="font-family:'宋体';"></span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t10"></a>
<a name="t11" style="color:rgb(202,0,0);"></a><span style="font-size:32px;color:rgb(255,0,0);">11</span><span style="font-size:32px;color:rgb(255,0,0);"><span style="font-family:'宋体';">、结构与联合有和区别？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;">
</p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">(1).&nbsp;<span style="font-family:'宋体';">结构和联合都是由多个不同的数据类型成员组成</span><span style="font-family:'ˎ̥';">,&nbsp;</span><span style="font-family:'宋体';">但在任何同一时刻</span><span style="font-family:'ˎ̥';">,&nbsp;</span><span style="font-family:'宋体';">联合中只存放了一个被选中的成员（所有成员共用一块地址空间）</span><span style="font-family:'ˎ̥';">,&nbsp;</span><span style="font-family:'宋体';">而结构的所有成员都存在（不同成员的存放地址不同）。&nbsp;</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">(2).&nbsp;<span style="font-family:'宋体';">对于联合的不同成员赋值</span><span style="font-family:'ˎ̥';">,&nbsp;</span><span style="font-family:'宋体';">将会对其它成员重写</span><span style="font-family:'ˎ̥';">,&nbsp;</span><span style="font-family:'宋体';">原来成员的值就不存在了</span><span style="font-family:'ˎ̥';">,&nbsp;</span><span style="font-family:'宋体';">而对于结构的不同成员赋值是互不影响的。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t11"></a>
<a name="t12" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">12<span style="font-family:'宋体';">、</span>试写出程序结果：</span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">int&nbsp;&nbsp;a=4;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">int&nbsp;&nbsp;&amp;f(int&nbsp;&nbsp;x)</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">{&nbsp;&nbsp;&nbsp;&nbsp;a=a+x;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;a;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">}</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">int&nbsp;main(void)</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;t=5;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;f(t)&lt;&lt;endl;&nbsp;&nbsp;a&nbsp;=&nbsp;9</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;f(t)=20;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;20</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;f(t)&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;5,a&nbsp;=&nbsp;20&nbsp;&nbsp;a&nbsp;=&nbsp;25</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t=f(t);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;30&nbsp;t&nbsp;=&nbsp;30</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;f(t)&lt;&lt;endl;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;60</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;">}</span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t12"></a>
<a name="t13" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">&nbsp;13</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">重载（</span><span style="font-family:'ˎ̥';">overload)</span><span style="font-family:'宋体';">和重写</span><span style="font-family:'ˎ̥';">(overried</span><span style="font-family:'宋体';">，有的书也叫做</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">覆盖</span><span style="font-family:'ˎ̥';">”</span><span style="font-family:'宋体';">）的区别？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">常考的题目。从定义上来说：</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">重写：是指子类重新定义父类虚函数的方法。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">从实现原理上来说：</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：<span style="font-family:'ˎ̥';">function&nbsp;func(p:integer):integer;</span><span style="font-family:'宋体';">和</span><span style="font-family:'ˎ̥';">function&nbsp;func(p:string):integer;</span><span style="font-family:'宋体';">。那么编译器做过修饰后的函数名称可能是这样的：</span><span style="font-family:'ˎ̥';">int_func</span><span style="font-family:'宋体';">、</span><span style="font-family:'ˎ̥';">str_func</span><span style="font-family:'宋体';">。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">&nbsp;&nbsp;</span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t13"></a>
<a name="t14" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">&nbsp;14</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">有哪几种情况只能用</span><span style="font-family:'ˎ̥';">intialization&nbsp;list&nbsp;</span><span style="font-family:'宋体';">而不能用</span><span style="font-family:'ˎ̥';">assignment?</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">答案：当类中含有<span style="font-family:'ˎ̥';">const</span><span style="font-family:'宋体';">、</span><span style="font-family:'ˎ̥';">reference&nbsp;</span><span style="font-family:'宋体';">成员变量；基类的构造函数都需要初始化表。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t14"></a>
<a name="t15" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">15</span><span style="font-size:32px;color:rgb(255,0,0);">.&nbsp;C++<span style="font-family:'宋体';">是不是类型安全的？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">答案：不是。两个不同类型的指针之间可以强制转换（用<span style="font-family:'ˎ̥';">reinterpret&nbsp;cast)</span><span style="font-family:'宋体';">。</span><span style="font-family:'ˎ̥';">C#</span><span style="font-family:'宋体';">是类型安全的。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t15"></a>
<a name="t16" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">16</span><span style="font-size:32px;color:rgb(255,0,0);">.&nbsp;main&nbsp;<span style="font-family:'宋体';">函数执行以前，还会执行什么代码？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">答案：全局对象的构造函数会在<span style="font-family:'ˎ̥';">main&nbsp;</span><span style="font-family:'宋体';">函数之前执行。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t16"></a>
<a name="t17" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">17</span><span style="font-size:32px;color:rgb(255,0,0);">.&nbsp;<span style="font-family:'宋体';">描述内存分配方式以及它们的区别</span><span style="font-family:'ˎ̥';">?</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">1<span style="font-family:'宋体';">）&nbsp;从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，</span><span style="font-family:'ˎ̥';">static&nbsp;</span><span style="font-family:'宋体';">变量。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">2<span style="font-family:'宋体';">）&nbsp;在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">3<span style="font-family:'宋体';">）&nbsp;从堆上分配，亦称动态内存分配。程序在运行的时候用</span><span style="font-family:'ˎ̥';">malloc&nbsp;</span><span style="font-family:'宋体';">或</span><span style="font-family:'ˎ̥';">new&nbsp;</span><span style="font-family:'宋体';">申请任意多少的内存，程序员自己负责在何时用</span><span style="font-family:'ˎ̥';">free&nbsp;</span><span style="font-family:'宋体';">或</span><span style="font-family:'ˎ̥';">delete&nbsp;</span><span style="font-family:'宋体';">释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t17"></a>
<a name="t18" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">&nbsp;18</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">分别写出</span><span style="font-family:'ˎ̥';">BOOL,int,float,</span><span style="font-family:'宋体';">指针类型的变量</span><span style="font-family:'ˎ̥';">a&nbsp;</span><span style="font-family:'宋体';">与</span><span style="font-family:'ˎ̥';">“</span><span style="font-family:'宋体';">零</span><span style="font-family:'ˎ̥';">”</span><span style="font-family:'宋体';">的比较语句。</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">答案：</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">BOOL&nbsp;:&nbsp;if&nbsp;(&nbsp;!a&nbsp;)&nbsp;or&nbsp;if(a)</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">int&nbsp;:&nbsp;if&nbsp;(&nbsp;a&nbsp;==&nbsp;0)</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">float&nbsp;:&nbsp;const&nbsp;EXPRESSION&nbsp;EXP&nbsp;=&nbsp;0.000001</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">if&nbsp;(&nbsp;a&nbsp;&lt;&nbsp;EXP&nbsp;&amp;&amp;&nbsp;a&nbsp;&gt;-EXP)</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">pointer&nbsp;:&nbsp;if&nbsp;(&nbsp;a&nbsp;!=&nbsp;NULL)&nbsp;or&nbsp;if(a&nbsp;==&nbsp;NULL)</span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t18"></a>
<a name="t19" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">19</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">请说出</span><span style="font-family:'ˎ̥';">const</span><span style="font-family:'宋体';">与</span><span style="font-family:'ˎ̥';">#define&nbsp;</span><span style="font-family:'宋体';">相比，有何优点？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">答案：</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">c</span><span style="font-size:18px;color:rgb(0,0,0);">onst<span style="font-family:'宋体';">作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被</span><span style="font-family:'ˎ̥';">Const</span><span style="font-family:'宋体';">修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">1<span style="font-family:'宋体';">）&nbsp;</span><span style="font-family:'ˎ̥';">const&nbsp;</span><span style="font-family:'宋体';">常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">2<span style="font-family:'宋体';">）&nbsp;有些集成化的调试工具可以对</span><span style="font-family:'ˎ̥';">const&nbsp;</span><span style="font-family:'宋体';">常量进行调试，但是不能对宏常量进行调试。</span></span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t19"></a>
<a name="t20" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(255,0,0);">20</span><span style="font-size:32px;color:rgb(255,0,0);">.<span style="font-family:'宋体';">简述数组与指针的区别？</span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">(1)<span style="font-family:'宋体';">修改内容上的差别</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">char&nbsp;a[]&nbsp;=&nbsp;“hello”;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">a[0]&nbsp;=&nbsp;‘X’;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">char&nbsp;*p&nbsp;=&nbsp;“world”;&nbsp;//&nbsp;<span style="font-family:'宋体';">注意</span><span style="font-family:'ˎ̥';">p&nbsp;</span><span style="font-family:'宋体';">指向常量字符串</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">p[0]&nbsp;=&nbsp;‘X’;&nbsp;//&nbsp;<span style="font-family:'宋体';">编译器不能发现该错误，运行时错误</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">(2)&nbsp;<span style="font-family:'宋体';">用运算符</span><span style="font-family:'ˎ̥';">sizeof&nbsp;</span><span style="font-family:'宋体';">可以计算出数组的容量（字节数）。</span><span style="font-family:'ˎ̥';">sizeof(p),p&nbsp;</span><span style="font-family:'宋体';">为指针得到的是一个指针变量的字节数，而不是</span><span style="font-family:'ˎ̥';">p&nbsp;</span><span style="font-family:'宋体';">所指的内存容量。</span><span style="font-family:'ˎ̥';">C++/C&nbsp;</span><span style="font-family:'宋体';">语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">char&nbsp;a[]&nbsp;=&nbsp;"hello&nbsp;world";</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">char&nbsp;*p&nbsp;=&nbsp;a;</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">cout&lt;&lt;&nbsp;sizeof(a)&nbsp;&lt;&lt;&nbsp;endl;&nbsp;//&nbsp;12&nbsp;<span style="font-family:'宋体';">字节</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">cout&lt;&lt;&nbsp;sizeof(p)&nbsp;&lt;&lt;&nbsp;endl;&nbsp;//&nbsp;4&nbsp;<span style="font-family:'宋体';">字节</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">计算数组和指针的内存容量</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">void&nbsp;Func(char&nbsp;a[100])</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">{</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">cout&lt;&lt;&nbsp;sizeof(a)&nbsp;&lt;&lt;&nbsp;endl;&nbsp;//&nbsp;4&nbsp;<span style="font-family:'宋体';">字节而不是</span><span style="font-family:'ˎ̥';">100&nbsp;</span><span style="font-family:'宋体';">字节</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:18px;color:rgb(0,0,0);">}</span></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t20"></a>
<a name="t21" style="color:rgb(202,0,0);"></a><span style="color:rgb(0,0,153);"><span style="font-size:32px;">第21题： int&nbsp;(*s[10])(int)&nbsp;<span style="font-family:'宋体';">表示的是什么？</span></span></span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);"><span style="font-family:Verdana;">int&nbsp;(*s[10])(int)&nbsp;</span><span style="font-family:'宋体';">函数指针数组，每个指针指向一个</span><span style="font-family:Verdana;">int&nbsp;func(int&nbsp;param)</span><span style="font-family:'宋体';">的函数。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t21"></a>
<a name="t22" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(0,0,153);">第22题：栈内存与文字常量区</span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
</p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="color:rgb(75,75,75);"><span style="font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:24px;color:rgb(0,0,0);">char&nbsp;str1[]&nbsp;=&nbsp;"abc";</span></span></span><span style="font-size:24px;"><br></span><span style="font-size:24px;">　　<span style="font-family:Verdana;">char&nbsp;str2[]&nbsp;=&nbsp;"abc";</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;">　　<span style="font-family:Verdana;">const&nbsp;char&nbsp;str3[]&nbsp;=&nbsp;"abc";</span></span><span style="font-size:24px;"><br></span><span style="font-size:24px;">　　<span style="font-family:Verdana;">const&nbsp;char&nbsp;str4[]&nbsp;=&nbsp;"abc";</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;">　　<span style="font-family:Verdana;">const&nbsp;char&nbsp;*str5&nbsp;=&nbsp;"abc";</span></span><span style="font-size:24px;"><br></span><span style="font-size:24px;">　　<span style="font-family:Verdana;">const&nbsp;char&nbsp;*str6&nbsp;=&nbsp;"abc";</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;">　　<span style="font-family:Verdana;">char&nbsp;*str7&nbsp;=&nbsp;"abc";</span></span><span style="font-size:24px;"><br></span><span style="font-size:24px;">　　<span style="font-family:Verdana;">char&nbsp;*str8&nbsp;=&nbsp;"abc";</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;">　　<span style="font-family:Verdana;">cout&nbsp;&lt;&lt;&nbsp;(&nbsp;str1&nbsp;==&nbsp;str2&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;</span></span><span style="font-size:24px;">//0&nbsp;&nbsp;<span style="font-family:'宋体';">分别指向各自的栈内存</span></span><span style="font-size:24px;"><br></span><span style="font-size:24px;">　　<span style="font-family:Verdana;">cout&nbsp;&lt;&lt;&nbsp;(&nbsp;str3&nbsp;==&nbsp;str4&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;</span></span><span style="font-size:24px;">//0&nbsp;&nbsp;<span style="font-family:'宋体';">分别指向各自的栈内存</span></span><span style="font-size:24px;"><br></span><span style="font-size:24px;">　　<span style="font-family:Verdana;">cout&nbsp;&lt;&lt;&nbsp;(&nbsp;str5&nbsp;==&nbsp;str6&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;</span></span><span style="font-size:24px;">//1<span style="font-family:'宋体';">指向文字常量区地址相同</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;">　　<span style="font-family:Verdana;">cout&nbsp;&lt;&lt;&nbsp;(&nbsp;str7&nbsp;==&nbsp;str8&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;</span></span><span style="font-size:24px;">//1<span style="font-family:'宋体';">指向文字常量区地址相同</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">　　结果是：<span style="font-family:Verdana;">0&nbsp;0&nbsp;1&nbsp;1</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">　　解答：<span style="font-family:Verdana;">str1,str2,str3,str4</span><span style="font-family:'宋体';">是数组变量，它们有各自的内存空间；而</span><span style="font-family:Verdana;">str5,str6,str7,str8</span><span style="font-family:'宋体';">是指针，它们指向相同的常量区域。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t22"></a>
<a name="t23" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(0,0,153);">第23题：将程序跳转到指定内存地址</span></h1>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t23"></a>
</h1><p>
<span style="color:rgb(0,0,153);"><span style="font-family:'宋体';">要对绝对地址</span><span style="font-family:Verdana;">0x100000</span><span style="font-family:'宋体';">赋值，我们可以用</span><span style="font-family:Verdana;">(unsigned&nbsp;int*)0x100000&nbsp;=&nbsp;1234;</span><span style="font-family:'宋体';">那么要是想让程序跳转到绝对地址是</span><span style="font-family:Verdana;">0x100000</span><span style="font-family:'宋体';">去执行，应该怎么做？</span></span></p>
<p>
<span style="color:rgb(75,75,75);"><br></span><span style="color:rgb(75,75,75);">　<span style="color:rgb(255,0,0);">　<span style="font-family:Verdana;">*((void&nbsp;(*)(&nbsp;))0x100000&nbsp;)&nbsp;(&nbsp;);</span></span></span><span style="color:rgb(255,0,0);"><br></span><span style="color:rgb(255,0,0);">　　首先要将<span style="font-family:Verdana;">0x100000</span><span style="font-family:'宋体';">强制转换成函数指针</span><span style="font-family:Verdana;">,</span><span style="font-family:'宋体';">即</span><span style="font-family:Verdana;">:</span></span><span style="color:rgb(255,0,0);"><br></span><span style="color:rgb(255,0,0);">　　<span style="font-family:Verdana;">(void&nbsp;(*)())0x100000</span></span><span style="color:rgb(255,0,0);"><br></span><span style="color:rgb(255,0,0);">　　然后再调用它<span style="font-family:Verdana;">:</span></span><span style="color:rgb(255,0,0);"><br></span><span style="color:rgb(255,0,0);">　　<span style="font-family:Verdana;">*((void&nbsp;(*)())0x100000)();</span></span><span style="color:rgb(255,0,0);"><br></span><span style="color:rgb(255,0,0);">　　用<span style="font-family:Verdana;">typedef</span><span style="font-family:'宋体';">可以看得更直观些</span><span style="font-family:Verdana;">:</span></span><span style="color:rgb(255,0,0);"><br></span><span style="color:rgb(255,0,0);">　　<span style="font-family:Verdana;">typedef&nbsp;void(*)()&nbsp;voidFuncPtr;</span></span><span style="color:rgb(255,0,0);"><br></span><span style="color:rgb(255,0,0);">　　<span style="font-family:Verdana;">*((voidFuncPtr)0x100000)();</span></span></p>
<p>
<br></p>

<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t24"></a>
<a name="t25" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(0,0,153);">第24题：int id[sizeof(unsigned long)];这个对吗？为什么？</span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br><span style="color:rgb(255,0,0);"><span style="font-size:24px;">&nbsp;答案:正确 这个 sizeof是编译时运算符，编译时就确定了&nbsp; ,可以看成和机器有关的常量。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t25"></a>
<a name="t26" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(0,0,153);">第25题：引用与指针有什么区别？</span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br><span style="font-size:24px;color:rgb(255,0,0);">【参考答案】&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br>
1) 引用必须被初始化，指针不必。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">2) 引用初始化以后不能被改变，指针可以改变所指的对象。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">3) 不存在指向空值的引用，但是存在指向空值的指针。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t26"></a>
<a name="t27" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(0,0,153);">第26题：const&nbsp; 与 #define 的比较 ，const有什么优点?</span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br><span style="font-size:24px;color:rgb(255,0,0);">&nbsp;【参考答案】</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。<br></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">（2）&nbsp; 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</span><br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:32px;color:rgb(0,0,153);">第27题：复杂声明<span style="font-size:24px;color:rgb(255,0,0);"><br></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<u><span style="font-size:32px;"><span style="font-size:24px;">void * ( * (*fp1)(int))[10];<br></span></span></u></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<u><span style="font-size:32px;"><span style="font-size:24px;">float (*(* fp2)(int,int,int))(int);</span></span></u></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<u><span style="font-size:32px;"><span style="font-size:24px;">int (* ( * fp3)())[10]();</span></span></u></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:32px;color:rgb(0,0,153);"><span style="font-size:24px;color:rgb(255,0,0);"><u><span style="color:rgb(0,0,0);">分别表示什么意思？</span></u><br>
【标准答案】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:32px;color:rgb(0,0,153);"><span style="font-size:24px;color:rgb(255,0,0);">1.void * ( * (*fp1)(int))[10]; &nbsp;&nbsp;fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。</span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:32px;color:rgb(0,0,153);"><span style="font-size:24px;color:rgb(255,0,0);">2.float (*(* fp2)(int,int,int))(int); &nbsp;&nbsp;fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。<br><br>
3.int (* ( * fp3)())[10](); &nbsp;&nbsp;fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。<br></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t27"></a>
<a name="t28" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(0,0,153);">第28题：内存的分配方式有几种?</span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span><span style="font-size:24px;"><span style="color:rgb(255,0,0);"><span>【参考答案】</span></span></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span><span style="font-size:24px;"><span style="color:rgb(255,0,0);"><span>一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</span></span></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span><span style="font-size:24px;"><span style="color:rgb(255,0,0);"><span>二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</span></span></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span><span style="font-size:24px;"><span style="color:rgb(255,0,0);"><span>三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</span></span></span></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t28"></a>
<a name="t29" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(0,0,153);">第29题：基类的析构函数不是虚函数，会带来什么问题？</span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">【参考答案】派生类的析构函数用不上，会造成资源的泄漏。</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<br></p>
<h1 style="font-family:Arial;line-height:26px;color:rgb(51,51,51);"><a name="t29"></a>
<a name="t30" style="color:rgb(202,0,0);"></a><a style="color:rgb(51,102,153);"></a><span style="font-size:32px;color:rgb(0,0,153);">第30题：全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？</span></h1>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">【参考答案】</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">生命周期不同：</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。&nbsp;<br></span></p>
<p style="font-family:Arial;font-size:14px;line-height:26px;color:rgb(51,51,51);">
<span style="font-size:24px;color:rgb(255,0,0);">操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</span></p>
<div><span style="font-size:24px;color:rgb(255,0,0);"><br></span></div>
</div>

## 参考博文：

**参考：** [ c++常见面试题30道](https://blog.csdn.net/fakine/article/details/51321544)

![](https://raw.githubusercontent.com/touwoyimuli/FigureBed/master/img/20190719175818.png)

<br>

## 本篇同步博文：



<font color=#FE7207  size=4 face="幼圆">**本博文同步到github.io博客：**</font> [c++常见面试题30道](https://blog.csdn.net/qq_33154343/article/details/97026882)

