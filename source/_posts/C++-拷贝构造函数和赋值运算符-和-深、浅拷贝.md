---
title: C++ 拷贝构造函数和赋值运算符 和 深、浅拷贝
date: 2019-7-23 19:00:07
toc: true
categories: 
 - [学习 - c/c++]
tags: 
 - 原理
---



**简介：**  本文主要介绍了拷贝构造函数和赋值运算符的区别，以及在什么时候调用拷贝构造函数、什么情况下调用赋值运算符。最后，简单的分析了下深拷贝和浅拷贝的问题

<!-- more -->

[TOC]

## 本博文的简述or解决问题？

​		本文主要介绍了拷贝构造函数和赋值运算符的区别，以及在什么时候调用拷贝构造函数、什么情况下调用赋值运算符。最后，简单的分析了下深拷贝和浅拷贝的问题

<br>

## 开发平台环境：

**编程环境：**  `win10 x64 专业版`          **编程软件：**  `visual studio 2015`

<br>

## <font color=#D0087E  face="幼圆">重要提示：</font>

<font color=#70AD47 size=4 face="幼圆">推荐点击文末的同步博客链接，查看本文，获得100%的浏览体验效果</font>

- 若遇csdn的博文的排版异常，图片无法加载，无法替换显示，则会删除异常部分（文末为无删减版）
- 无法预览的视频，则会替换为其链接；若学习资源分享失效，请评论区留言或留下邮箱
- <font color=#D0087E  size=4 face="幼圆">**请点击<font color=#FE7207  size=4 face="幼圆">本文末的同步链接</font>，在 [github.io](https://touwoyimuli.github.io/) 博客上查看更好的100%效果体验**</font> 

<br>

## 拷贝构造函数和赋值运算符

在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符。但用户可以使用`delete`来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算。

```
class Person
{
public:

    Person(const Person& p) = delete;

    Person& operator=(const Person& p) = delete;

private:
    int age;
    string name;
};
```

上面的定义的类`Person`显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示_无法调用该函数，它是已删除的函数_。
还有一点需要注意的是，**拷贝构造函数必须以引用的方式传递参数**。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

### 何时调用

拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个**已经存在的实例**。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。**调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符**。

调用拷贝构造函数主要有以下场景：

- 对象作为函数的参数，以值传递的方式传给函数。　
- 对象作为函数的返回值，以值的方式从函数返回
- 使用一个对象给另一个对象**初始化**

代码如下：

```cpp
class Person
{
public:
	Person() 
	{ 
		cout << "拷贝构造A" << endl;
	}

	Person(const Person& p)
	{
		cout << "拷贝构造B" << endl;
	}

	Person& operator=(const Person& p)
	{
		cout << "赋值构造C" << endl;
		return *this;
	}

private:
	int age;
	string name;
};

void f(Person p)
{
	return;
}

Person f1()
{
	Person p;
	return p;
}

int main()
{
	Person p;   
	cout << "---------分割线1--------"<< endl;
	Person p1 = p;     // 1
	cout << "&p1:" << &p1 << "   &p:" << &p << endl;
	cout << "---------分割线2--------" << endl;
	Person p2;        
	cout << "---------分割线3--------" << endl;
	p2 = p;           // 2 
	cout << "---------分割线4--------" << endl;
	f(p2);            // 3 
	cout << "---------分割线5--------" << endl;
	p2 = f1();        // 4 
	cout << "---------分割线6--------" << endl;
	Person p3 = f1(); // 5

	return 0;
}
```

上面代码中定义了一个类`Person`，显式的定义了拷贝构造函数和赋值运算符。然后定义了两个函数:`f`，以值的方式参传入Person对象；`f1`，以值的方式返回Person对象。在`main`中模拟了5中场景，测试调用的是拷贝构造函数还是赋值运算符。执行结果如下：
<img src="https://raw.githubusercontent.com/touwoyimuli/FigureBed/master/img/20190723190437.png"/>

**分析如下：**

1. 这是虽然使用了"="，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的是拷贝构造函数。
2. 首先声明一个对象p2，然后使用赋值运算符"="，将p的值复制给p2，显然是调用赋值运算符，为一个已经存在的对象赋值 。
3. 以值传递的方式将对象p2传入函数f内，调用拷贝构造函数构建一个函数f可用的实参。
4. 这条语句拷贝构造函数和赋值运算符都调用了。函数f1以值的方式返回一个Person对象，在返回时会调用拷贝构造函数创建一个临时对象tmp作为返回值；返回后调用赋值运算符将临时对象tmp赋值给p2.
5. 按照4的解释，应该是首先调用拷贝构造函数创建临时对象；然后再调用拷贝构造函数使用刚才创建的临时对象创建新的对象p3，也就是会调用两次拷贝构造函数。不过，编译器也没有那么傻，应该是直接调用拷贝构造函数使用返回值创建了对象p3。

<br>

### 深拷贝、浅拷贝

说到拷贝构造函数，就不得不提深拷贝和浅拷贝。通常，默认生成的拷贝构造函数和赋值运算符，只是简单的进行值的复制。例如：上面的`Person`类，字段只有`int`和`string`两种类型，这在拷贝或者赋值时进行值复制创建的出来的对象和源对象也是没有任何关联，对源对象的任何操作都不会影响到拷贝出来的对象。反之，假如`Person`有一个对象为`int *`，这时在拷贝时还只是进行值复制，那么创建出来的`Person`对象的`int *`的值就和源对象的`int *`指向的是同一个位置。任何一个对象对该值的修改都会影响到另一个对象，这种情况就是浅拷贝。

深拷贝和浅拷贝主要是针对类中的**指针**和**动态分配的空间**来说的，因为对于指针只是简单的值复制并不能分割开两个对象的关联，任何一个对象对该指针的操作都会影响到另一个对象。这时候就需要提供自定义的**深拷贝**的拷贝构造函数，消除这种影响。通常的原则是：

- 含有指针类型的成员或者有动态分配内存的成员都应该提供自定义的拷贝构造函数
- 在提供拷贝构造函数的同时，还应该考虑实现自定义的赋值运算符

对于拷贝构造函数的实现要确保以下几点：

- 对于值类型的成员进行值复制
- 对于指针和动态分配的空间，在拷贝中应重新分配分配空间
- 对于基类，要调用基类合适的拷贝方法，完成基类的拷贝

<br>

## 总结

- 拷贝构造函数和赋值运算符的行为比较相似，却产生不同的结果；拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。
- 关于深拷贝和浅拷贝。当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。

<br>

## 参考博文：

因为有着热心网友的无私分享，故不辞辛苦也将自己的项目或经验整理成博客的形式，也提供给一起大家学习探讨与交流 

**参考一：**  [C++ 拷贝构造函数和赋值运算符](https://www.cnblogs.com/wangguchangqing/p/6141743.html)

![](https://raw.githubusercontent.com/touwoyimuli/FigureBed/master/img/20190719175818.png)

<br>

## 本篇同步博文：

<font color=#FE7207  size=4 face="幼圆">**本博文同步到csdn博客：**</font> [C++ 拷贝构造函数和赋值运算符 和 深、浅拷贝](https://blog.csdn.net/qq_33154343/article/details/97022362)

